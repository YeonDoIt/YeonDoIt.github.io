---
title: "복잡도(Complexity)"
author: yeon
date: 2024-05-31 00:34:00 +0800
categories: [DEV, Algorithm]
tags: [Complexity]
---

좋은 멘토님을 만나 인생 첫 세미나를 진행했다.

주제로 복잡도, 스택, 큐에 대해 조사하고 각자 PPT를 만들어서 발표를 하는 세미나를 진행했는데, 내용을 정리하면서 글로 남기고 싶어 쓰게 되었다.

# 복잡도 종류
1. 시간 복잡도(Time Complexity)   
: 알고리즘이 입력 데이터의 크기에 따라 `실행 시간`이 어떻게 변화하는지를 나타내는 지표
2. 공간 복잡도(Space Comlexity)   
: 알고리즘이 입력 데이터의 크기에 따라 사용하는 `메모리 공간`이 어떻게 변화하는지를 나타내는 지표

# 복잡도 표기법
- Big-O(빅-오)   
: 알고리즘의 `최악`의 경우 복잡도를 나타냄, 복잡도를 표기할 때 주로 사용하는 표기법
- Big-Ω (빅-오메가)   
: 알고리즘의 `최선`의 경우 복잡도를 나타냄
- Big-Θ (빅-세타)   
: 알고리즘의 `평균`의 경우 복잡도를 나타냄

# 왜 최악의 경우를 일반적으로 사용할까?
같은 기능을 하는 다른 복잡도를 가진 알고리즘을 컴퓨터가 처리할 때 더욱 성능을 향상시키기 위해서 개발자는 알고리즘의 최악의 경우를 생각해야 한다!

# 복잡도 계산
```java
public static void main(String[] args) {
	int[] numbers = {1, 2, 3, 4, 5};
    print(numbers);
}

private static void print(int[] arr) {
	for(int i = 0; i < arr.length; i++) {
    	for(int j = 0; j < arr.length; j++) {
        	System.out.println(arr[i] + ", " + arr[j]);
        }
    }
}
```
위의 예시 print() 메소드의 시간 복잡도를 계산해보자.

> 실행되는 코드의 수 : (arr의 길이) x (arr의 길이) = 5 x 5 = 25   
arr의 길이 = n 이라 하면, 실행되는 코드의 수는 n² 이다.   
따라서, 시간 복잡도는 O(n²) 이다.

# 복잡도 계산 규칙
1. 계수, 상수항은 무시한다.
> ex) O(3n²) = O(n²), O(12) = O(1)

2. 영향력 없는 항은 무시한다.
> ex) O(n²+n) = O(n²)

3. 두가지 항의 변수가 다르면 그대로 둔다.
> ex) O(n²+m)

# 복잡도 비교
복잡도에 관련해서 검색을 해보면 항상 나오는 복잡도 비교 그래프가 있다.

![복잡도 비교 그래프](/assets/img/Complexity/Complexity1.png)

> O(1) < O(log n)  < O(n) < O(n log n) < O(n²) < O(2^n) < O(n!)

- O(log n) : 이진 검색
- O(n log n) : 병합 정렬
- O(2^n) : 피보나치 수열
- O(n!) : 팩토리얼

# 1초
이제 코딩테스트를 풀다가 보면 시간 제한이 들어가 있는 문제들이 있다.

시간 제한 문제를 풀기 위해서는 기본적으로 시간복잡도 몇이 1초인지를 알아둘 필요가 있다.

> O(100,000,000) = 약 1초

기초적인 내용이지만, 프로그래머의 첫 시작은 복잡도부터라고 생각한다.

이러한 복잡도를 알아야지만 나중에 코드를 작성하면서 더 효율적인 로직을 생각할 수 있고, 프로그래머로서의 가치가 더 올라갈 수 있다는 것을 명심하자!