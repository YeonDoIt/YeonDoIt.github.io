---
title: "메모리의 주소 공간"
author: yeon
date: 2024-10-20 20:06:00 +0900
categories: [DEV, ComputerArchitecture]
tags: [물리 주소, 논리 주소, MMU, 베이스 레지스터, 한계 레지스터]
---

![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image.png)
- 논리 주소와 물리 주소로 주소 공간을 나눈 이유?
- 논리 주소를 물리 주소로 변환하는 방법?

## 물리 주소와 논리 주소

> Q : CPU와 실행중인 프로그램은 현재 메모리 몇번지에 무엇이 저장되어 있는지 다 알고 있을까?   
A : No! CPU와 실행중인 프로그램은 메모리 몇번지에 무엇이 저장되어 있는지 다 알지 못한다.   
Why? 메모리에 저장된 값들은 시시각각 변하기 때문 (새롭게 실행되는 프로그램은 새롭게 메모리에 적재, 실행이 끝난 프로그램은 메모리에서 삭제, 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐)

### 물리 주소

- 메모리 입장에서 바라본 주소
- 말 그대로 정보가 실제로 저장된 하드웨어상의 주소

### 논리 주소

- CPU와 실행중인 프로그램 입장에서 바라본 주소
- 실행중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소

## 물리 주소와 논리 주소의 변환

![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-1.png)
- **MMU(메모리 관리 장치)** 라는 하드웨어에 의해 변환
- MMU는 **논리 주소**와 **베이스 레지스터(프로그램의 기준주소)** 값을 더하여 논리 주소를 물리 주소로 변환

![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-2.png)
![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-3.png)

- 베이스 레지스터 : 프로그램의 **가장 작은 물리 주소(프로그램의 첫 물리 주소)** 를 저장하는 셈
- 논리 주소 : 프로그램의 시작점으로부터 **떨어진 거리**인 셈

## 메모리 보호

> Q : 이런 명령어는 실행되어도 안전할까?   
![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-4.png)   
A : No!   
![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-5.png)

### 한계 레지스터

- 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장
- 베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값
![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-6.png)

- CPU가 접근하려는 논리 주소는 한계 레지스터가 저장한 값보다 커서는 안됨
![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-7.png)

- 베이스 레지스터에 100, 한계 레지스터에 150이 저장되어 있다고 가정
    - 물리 주소 시작점이 이 100번지, 프로그램의 크기(논리 주소의 최대 크기)는 150

![alt text](/assets/img/ComputerArchitecture/메모리의주소공간/image-8.png)
- 이처럼 CPU는 메모리에 접근하기 전, 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사
- 실행중인 프로그램의 독립적인 실행 공간을 확보 & 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호