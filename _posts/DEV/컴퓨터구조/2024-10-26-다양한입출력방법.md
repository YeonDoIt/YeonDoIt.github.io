---
title: "다양한 입출력방법"
author: yeon
date: 2024-10-26 19:12:00 +0900
categories: [DEV, 컴퓨터구조]
tags: [프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력]
---

- 세 가지 입출력 방식 : 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image.png)

## 프로그램 입출력

- 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 입출력 명령어로써 장치 컨트롤러와 상호작용
- 메모리에 저장된 정보를 하드 디스크에 **백업** (= 하드 디스크에 새로운 정보 **쓰기**)
    - CPU는 하드 디스크 컨트롤러의 **제어 레지스터**에 **쓰기** 명령 내보내기
    ![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-1.png)
    - 하드 디스크 컨트롤러는 하드 디스크 상태 확인 → 상태 레지스터에 준비 완료 표시
    ![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-2.png)
    - CPU는 상태 레지스터를 주기적으로 읽어보여 하드 디스크의 준비 여부를 확인
    - 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓰기
    ![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-3.png)
    - 아직 백업 작업(쓰기 작업)이 끝나지 않았다면 1번부터 반복, 쓰기가 끝났다면 작업 종료

- 프로그램 입출력 방식 : **CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀**으로써 이루어진다.

> Q : CPU가 장치 컨트롤러의 레지스터들(입출력장치의 주소)을 어떻게 알까?   
ex. 프린터 컨트롤러의 상태 레지스터를 읽어라, 프린터 컨트롤러의 데이터 레지스터에 100을 써라, 키보드 컨트롤러의 상태 레지스터를 읽어라, 하드 디스크 컨트롤러의 데이터 레지스터에 ‘a’를 써라   
Q : 이런 명령어들은 어떻게 명령어로 표현되고, 어떻게 메모리에 저장될까?   
A : CPU가 장치 컨트롤러의 레지스터들을 알기 위한 방법으로 1. 메모리 맵 입출력 & 2. 고립형 입출력 방식을 사용한다.

### 메모리 맵 입출력

- 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-4.png)

### 고립형 입출력

- 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-5.png)

- (입출력 읽기/쓰기 선을 활성화시키는) 입출력 전용 명령어 사용

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-6.png)

### 메모리 맵 입출력 vs 고립형 입출력

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-7.png)

## 인터럽트 기반 입출력

- 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-8.png)

### 동시다발적인 인터럽트

- 입출력장치가 많을 때를 가정해보자

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-9.png)

- 인터럽트 발생 순서대로?

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-10.png)

- 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우
- 현실적으로 모든 인터럽트를 순차적으로 처리할 수 없다.
- 인터럽트 중에서도 **우선 순위가 높은 인터럽트**가 있다.

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-11.png)

- NMI가 발생한 경우, 플래그 레지스터 속 인터럽트 비트를 활성화한 채 인터럽트를 처리하는 경우

> PIC(Programmable Interrupt Controller)   
1.여러 장치 컨트롤러에 연결되어   
2.장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤   
3.CPU에게 지금 처리해야하는 인터럽트가 무엇인지 판단하는 하드웨어   
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-12.png)
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-13.png)
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-14.png)

## DMA 입출력

> Q : 프로그램 입출력, 인터럽트 기반 입출력의 공통점?   
A : 입출력장치와 메모리 간의 데이터 이동은 CPU가 주도하고 이동하는 데이터도 반드시 CPU를 거친다.   
Q : CPU가 바쁜 와중 하드 디스크 백업과 같이 대용량 데이터를 이동해야 한다면?

### DMA (Direct Memory Access)

- CPU를 거치지 않고 입출력장치가 메모리에 **직접적으로 접근**하는 기능

![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-15.png)

### DMA 입출력 과정

- CPU는 DMA 컨트롤러에 입출력 작업을 명령
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-17.png)
- DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행 (이 때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근)
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-16.png)
- 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-18.png)
- 즉, CPU는 입출력 작업의 시작과 끝만 관여
- But, 시스템 버스는 공용 자원이기에 동시 사용이 불가능한 문제 발생
![alt text](/assets/img/컴퓨터구조/다양한입출력방법/image-19.png)
- CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
- CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용

## 입출력 버스

- 시스템 버스를 (불필요하게) 두 번 이용하는 DMA 컨트롤러
- 입출력 버스를 통해 시스템 버스의 이용 빈도를 낮추기 위한 목적
- e.g. PCI 버스, PCI express (PCIe) 버스와 입출력 장치를 연결짓는 슬롯