---
title: "페이지 교체와 프레임 할당"
author: yeon
date: 2024-11-13 22:34:00 +0900
categories: [DEV, 운영체제]
tags: [요구 페이징, FIFO, LRU]
---

- 물리 메모리보다 큰 프로세스를 실행할 수 있지만, 그럼에도 물리 메모리의 크기는 한정되어 있음
- 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고 프로세스들에게 적절한 수의 프레임을 할당해야 함

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image.png)

## 요구 페이징

- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- 요구되는 페이지만 적재하는 기법
- 이러한 요구 페이징 시스템이 안정적으로 작동하려면 해결해야 할 문제?
    - 페이지 교체
    - 프레임 할당

## 페이지 교체 알고리즘

- 요구 페이징 기법으로 페이지들을 적재하다보면 언젠간 메모리가 가득 차게 됨
- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 함
- 이때, 어떤 페이지를 내보낼까? 이를 결정하는 방법(알고리즘)이 페이지 교체 알고리즘

> Q : 무엇이 좋은 페이지 교체 알고리즘일까?   
A : 페이지 폴트가 적은 알고리즘, 페이지 폴트가 발생하면 보조기억장치에 접근해야 하기 때문에 성능 저하 발생   
Q : 그럼 페이지 폴트 횟수는 어떻게 알 수 있을까?   
A : 페이지 참조열(page reference string), CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
> 

### FIFO 페이지 교체 알고리즘

- 가장 단순한 방식
- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
- “오래 머물렀다면 나가라”

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-1.png)

- 프로그램 실행 초기에 잠깐 실행될 페이지
- 프로그램 실행 내내 사용될 페이지 ← 먼저 적재되었다고 내쫓아선 안됨

### FIFO 페이지 교체 알고리즘 - 보완책

- 2차 기회(second-chance) 페이지 교체 알고리즘
- 참조 비트 1 : CPU가 한 번 참조한 적이 있는 페이지, 한 번 더 기회를 주기 (참조 비트 0으로 초기화 후 적재 시간을 현재 시간으로 설정)
- 참조 비트 2 : CPU가 참조한 적이 없는 페이지, 내쫓기

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-2.png)

### 최적 페이지 교체 알고리즘

- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-3.png)

- 가장 낮은 페이지 폴트율을 보장하는 페이지 교체 알고리즘
- But, 실제 구현이 어려움
- “앞으로 오랫동안 사용되지 않을 페이지? 어떻게 예측함?”
- 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주

### LRU(Least-Recently-Used) 페이지 교체 알고리즘

- 최적 페이지 교체 알고리즘 :  가장 오래 사용되지 않을 페이지 교체
- LRU 페이지 교체 알고리즘 : 가장 오래 사용되지 않은 페이지 교체
    - “최근에 사용되지 않은 페이지는 앞으로도 사용되지 않지 않을까?”

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-4.png)

### 기타 페이지 교체 알고리즘

- 이외에도 많은 페이지 교체 알고리즘들이 있음 (e.g. LRU 페이지 교체 알고리즘의 파생 알고리즘)
- 페이지 교체 알고리즘이란 무엇인지
- 페이지 교체는 왜 해야 하는지
- 무엇이 좋은 페이지 교체 알고리즘인지