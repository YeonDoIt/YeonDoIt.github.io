---
title: "페이지 교체와 프레임 할당"
author: yeon
date: 2024-11-13 22:34:00 +0900
categories: [DEV, 운영체제]
tags: [요구 페이징, FIFO, LRU, 페이지 폴트, 정적 할당 방식, 동적 할당 방식]
---

- 물리 메모리보다 큰 프로세스를 실행할 수 있지만, 그럼에도 물리 메모리의 크기는 한정되어 있음
- 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고 프로세스들에게 적절한 수의 프레임을 할당해야 함

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image.png)

## 요구 페이징

- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- 요구되는 페이지만 적재하는 기법
- 이러한 요구 페이징 시스템이 안정적으로 작동하려면 해결해야 할 문제?
    - 페이지 교체
    - 프레임 할당

## 페이지 교체 알고리즘

- 요구 페이징 기법으로 페이지들을 적재하다보면 언젠간 메모리가 가득 차게 됨
- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 함
- 이때, 어떤 페이지를 내보낼까? 이를 결정하는 방법(알고리즘)이 페이지 교체 알고리즘

> Q : 무엇이 좋은 페이지 교체 알고리즘일까?   
A : 페이지 폴트가 적은 알고리즘, 페이지 폴트가 발생하면 보조기억장치에 접근해야 하기 때문에 성능 저하 발생   
Q : 그럼 페이지 폴트 횟수는 어떻게 알 수 있을까?   
A : 페이지 참조열(page reference string), CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
> 

### FIFO 페이지 교체 알고리즘

- 가장 단순한 방식
- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
- “오래 머물렀다면 나가라”

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-1.png)

- 프로그램 실행 초기에 잠깐 실행될 페이지
- 프로그램 실행 내내 사용될 페이지 ← 먼저 적재되었다고 내쫓아선 안됨

### FIFO 페이지 교체 알고리즘 - 보완책

- 2차 기회(second-chance) 페이지 교체 알고리즘
- 참조 비트 1 : CPU가 한 번 참조한 적이 있는 페이지, 한 번 더 기회를 주기 (참조 비트 0으로 초기화 후 적재 시간을 현재 시간으로 설정)
- 참조 비트 2 : CPU가 참조한 적이 없는 페이지, 내쫓기

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-2.png)

### 최적 페이지 교체 알고리즘

- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-3.png)

- 가장 낮은 페이지 폴트율을 보장하는 페이지 교체 알고리즘
- But, 실제 구현이 어려움
- “앞으로 오랫동안 사용되지 않을 페이지? 어떻게 예측함?”
- 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주

### LRU(Least-Recently-Used) 페이지 교체 알고리즘

- 최적 페이지 교체 알고리즘 :  가장 오래 사용되지 않을 페이지 교체
- LRU 페이지 교체 알고리즘 : 가장 오래 사용되지 않은 페이지 교체
    - “최근에 사용되지 않은 페이지는 앞으로도 사용되지 않지 않을까?”

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-4.png)

### 기타 페이지 교체 알고리즘

- 이외에도 많은 페이지 교체 알고리즘들이 있음 (e.g. LRU 페이지 교체 알고리즘의 파생 알고리즘)
- 페이지 교체 알고리즘이란 무엇인지
- 페이지 교체는 왜 해야 하는지
- 무엇이 좋은 페이지 교체 알고리즘인지

## 스래싱과 프레임 할당

### 페이지 폴트가 자주 발생하는 이유

- 나쁜 페이지 교체 알고리즘을 사용해서
- 프로세스가 사용할 수 있는 프레임 자체가 적어서

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-5.png)

### 스래싱

- 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-6.png)

- 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것이 아님

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-7.png)

- 멀티프로그래밍의 정도 : 메모리에 동시에 실행되는 프로세스의 수
- 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
- 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 함

### 균등 할당 (equal allocation) - 정적 할당 방식

- 가장 단순한 할당 방식
- 모든 프로세스들에게 균등하게 프레임을 할당하는 방식

### 비례 할당 (proportional allocation) - 정적 할당 방식

- 프로세스의 크기를 고려하자
- 프로세스 크기에 비례하여 프레임 할당
- 크기가 큰 프로세스인데 막상 실행해보니 많은 프레임을 필요로 하지 않으면?
- 크기가 작은 프로세스인데 막살 실행해보니 많은 프레임을 필요로 하면?
- 결국 프로세스가 필요로 하는 프레임 수는 실행해봐야 앎

### 작업 집합 모델 - 동적 할당 방식

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
    - 그렇다면 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 됨
- ‘프로세스가 일정 기간 동안 참조한 페이지 집합’을 기억하여 빈번한 페이지 교체를 방지
    - 작업 집합이란 “실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합”
- 작업 집합을 구하려면 1. 프로세스가 참조한 페이지 2. 시간 간격이 필요

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-8.png)

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-9.png)

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-10.png)

### 페이지 폴트 빈도 - 동적 할당 방식

- 프로세스가 실행하는 과정에서 배분할 프레임 결정
- 두 개의 가정에서 생겨난 아이디어
    1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있음
    2. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있음
- 프로세스가 실행하는 과정에서 배분할 프레임 결정

![alt text](/assets/img/운영체제/페이지교체와프레임할당/image-11.png)

- 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식