---
title: "동기화 기법"
author: yeon
date: 2024-11-05 23:25:00 +0900
categories: [DEV, 운영체제]
tags: [뮤텍스 락, acquire, release, 세마포, wait, signal, 임계 구역, 모니터]
---

- 동기화 기법 중 뮤텍스 락, 세마포, 모니터

![alt text](/assets/img/운영체제/동기화기법/image.png)

## 뮤텍스 락

- 상호 배제를 위한 동기화 도구(자물쇠 역할), 뮤텍스 락

![alt text](/assets/img/운영체제/동기화기법/image-1.png)

- 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제하는 역할 : release 함수

```
acquire() {
	while (lock == true) /* 만약 임계 구역이 잠겨 있다면 */
		;                /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
	lock = true;         /* 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
}

release() {
	lock = false;        /* 임계 구역 작업이 끝났으니 잠금 해제 */
}
```

```
acquire(); // 자물쇠 잠겨있는지 확인, 잠겨있지 않다면 잠그고 들어가기
// 임계 구역 // 임계 구역에서의 작업 진행 // '총합' 변수 접근
release(); // 자물쇠 반환
```

### acquire 함수

- 프로세스가 임계 구역에 진입하기 전에 호출
- 임계 구역이 잠겨있다면
    - 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인
- 임계 구역이 열려있다면
    - 임계 구역을 잠그기(lock을 true로 바꾸기)

### release 함수

- 임계 구역에서의 작업이 끝나고 호출
- 현재 잠긴 임계 구역을 열기(lock을 false로 바꾸기)

### 바쁜 대기 (busy waiting)

```
while (lock == true) /* 만약 임계 구역이 잠겨있다면 */
		;                /* 임계 구역이 잠겨있는지를 반복적으로 확인 */
```

## 세마포

- 좀 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러개 있는 경우에도 적용 가능
- 세마포의 종류(이진 세마포, 카운팅 세마포) 중 카운팅 세마포를 다룸

![alt text](/assets/img/운영체제/동기화기법/image-2.png)

- 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리기
- 임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역 진입

![alt text](/assets/img/운영체제/동기화기법/image-3.png)

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 **전역 변수 S**
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 **wait 함수**
- 임계 구역 앞에서 기다리는 프로세스에 ‘이제 가도 좋다’고 신호를 주는 **signal 함수**

```
wait()
// 임계 구역
signal()
```

### wait 함수

```
wait () {
	while (S <= 0) /* 1. 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 */
	;              /* 2. 사용할 수 있는 자원이 있는지 반복적으로 확인하고, */
	S--;           /* 3. 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입 */
}
```

### signal 함수

```
signal () { 
	S++       /* 1. 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다. */
}
```

### 예시

- 세 개의 프로세스 P1, P2, P3가 두 개의 공유 자원(S=2)에 P1, P2, P3 순서로 접근한다고 가정

![alt text](/assets/img/운영체제/동기화기법/image-4.png)

1. 프로세스 P1 wait 호출, S는 현재 2이므로 S를 1 감소싴키고 임계 구역 진입
2. 프로세스 P2 wait 호출, S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입
3. 프로세스 P3 wait 호출, S는 현재 0이므로 무한히 반복하며 S 확인
4. 프로세스 P1 임계 구역 작업 종료, signal () 호출, S를 1 증가
5. 프로세스 P3 S가 1이 됨을 확인, S는 현재 1이므로 S를 1 감소시킥고 임계 구역 진입

### Busy waiting

- 마치 탈의실 문이 열렸는지/닫혔는지 반복적으로 확인하는 것과 같다. → CPU 사이클 낭비!
- 사용할 수 있는 자원이 없을 경우 **대기 상태**로 만듦 (해당 프로세스의 PCB를 대기 큐에 삽입)
- 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 **준비 상태**로 만듦 (해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)

```
wait () {
	S--;
	if (S < 0) {
		add this process to Queue; /* 1. 해당 프로세스 PCB를 대기 큐에 삽입한다. */
		sleep(); /* 2. 대기 상태로 접어든다. */
	}
}

signal () {
	S++;
	if (S <= 0) {
		remove a process p from Queue /* 1. 대기 큐에 있는 프로세스 p를 제거한다. */
		wakeup(p) /* 2. 프로세스 p를 대기 상태에서 준비 상태로 만든다. */
	}
}
```

- 세 개의 프로세스 P1, P2, P3가 두 개의 공유 자원(S=2)에 P1, P2, P3 순서로 접근한다고 가정

![alt text](/assets/img/운영체제/동기화기법/image-5.png)

1. 프로세스 P1 wait 호출, S를 1 감소시키면 S는 1 이므로 임계 구역 진입
2. 프로세스 P2 wait 호출, S를 1 감소시키면 S는 0 이므로 임계 구역 진입
3. 프로세스 P3 wait 호출, S를 1 감소시키면 S는 -1 이므로 본인의 PCB를 대기 큐에 넣고 대기 상태로 전환
4. 프로세스 P1 임계 구역 작업 종료, signal () 호출. S를 1 증가하면 0이므로 대기 상태였던 P3를 대기 큐에서 꺼내 준비 큐로 옮겨줌
5. 깨어난 프로세스 P3 임계 구역 진입
6. 프로세스 P2 임계 구역 작업 종료, signal () 호출. S가 1 증가하면 1
7. 프로세스 P3 임계 구역 작업 종료, signal () 호출. S가 1 증가하면 2

### 세마포를 활용한 실행 순서 동기화

- 세마포의 번수 S를 0으로 두고,
- 먼저 실행할 프로세스 뒤에 signal 함수,
- 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.

![alt text](/assets/img/운영체제/동기화기법/image-6.png)

## 모니터

- 매번 임계구역 앞뒤로 wait(), signal()을 호출해야 하나? 그러다 실수라도 하면?

![alt text](/assets/img/운영체제/동기화기법/image-7.png)

- 그래서 등장한 모니터, 사용자(개발자)가 다루기에 편한 동기화 도구

### 상호 배제를 위한 동기화

- 인터페이스를 위한 큐
- 공유자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
- 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용

![alt text](/assets/img/운영체제/동기화기법/image-8.png)

### 실행 순서 제어를 위한 동기화

- 조건 변수(condition variable) 이용
    - 조건 변수 : 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수

![alt text](/assets/img/운영체제/동기화기법/image-9.png)

- 조건변수.wait() : 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
- 조건변수.signal() : wait()으로 대기 상태로 접어든 조건변수를 실행 상태로 변경

![alt text](/assets/img/운영체제/동기화기법/image-10.png)
![alt text](/assets/img/운영체제/동기화기법/image-11.png)

- 모니터 안에는 하나의 프로세스만이 있을 수 있다
    - wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재개
    - signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal()을 호출한 프로세스의 수행을 재개
- 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단한다.
- 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개한다.